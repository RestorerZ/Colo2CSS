
Выполнение для события CursorHold автокоманды "*"
автокоманда call xolox#misc#cursorhold#autocmd()

Выполнение call xolox#misc#cursorhold#autocmd()
вызов xolox#misc#cursorhold#autocmd()

строка 1, команда   " The 'top level event handler' that's called by Vim whenever the
строка 2, команда   " [CursorHold][] or [CursorHoldI][] event fires. It iterates through the
строка 3, команда   " event handlers registered using `xolox#misc#cursorhold#register()` and
строка 4, команда   " calls each event handler at the appropriate interval, keeping track of
строка 5, команда   " the time when each event handler was last run.
строка 6, команда   for handler in g:xolox#misc#cursorhold#handlers
строка 7, команда     let function = handler['function']
строка 8, команда     let last_run = get(handler, 'last_run', 0)
строка 9, команда     let interval = get(handler, 'interval', 4)
строка 10, команда     call xolox#misc#msg#debug("vim-misc %s: Checking handler %s with interval %i and last run %i ..", g:xolox#misc#version, function, interval, last_run)
строка 11, команда     " Rate limit in case &updatetime is set (very) low.
строка 12, команда     let time_until_next_run = (last_run + interval) - localtime()
строка 13, команда     if time_until_next_run > 0
строка 14, команда       call xolox#misc#msg#debug("vim-misc %s: Rate limiting handler %s (time until next run: %i seconds).", g:xolox#misc#version, function, time_until_next_run)
строка 15, команда     else
строка 16, команда       call xolox#misc#msg#debug("vim-misc %s: Running handler %s ..", g:xolox#misc#version, function)
строка 17, команда       call call(function, get(handler, 'arguments', []))
строка 18, команда       let handler['last_run'] = localtime()
строка 19, команда     endif
строка 20, команда   endfor
xolox#misc#cursorhold#autocmd вернула #0

Начинается обработка для события CursorHold автокоманды "*"


Выполнение verbose call HiAttr2CssDecl({'bg': '#282828', 'wght': 1, 'rvrs': 1, 'color': '#fb4934'})
Выполнение для события CursorHold автокоманды "*"
автокоманда call xolox#misc#cursorhold#autocmd()

Выполнение call xolox#misc#cursorhold#autocmd()
вызов xolox#misc#cursorhold#autocmd()

строка 1, команда   " The 'top level event handler' that's called by Vim whenever the
строка 2, команда   " [CursorHold][] or [CursorHoldI][] event fires. It iterates through the
строка 3, команда   " event handlers registered using `xolox#misc#cursorhold#register()` and
строка 4, команда   " calls each event handler at the appropriate interval, keeping track of
строка 5, команда   " the time when each event handler was last run.
строка 6, команда   for handler in g:xolox#misc#cursorhold#handlers
строка 7, команда     let function = handler['function']
строка 8, команда     let last_run = get(handler, 'last_run', 0)
строка 9, команда     let interval = get(handler, 'interval', 4)
строка 10, команда     call xolox#misc#msg#debug("vim-misc %s: Checking handler %s with interval %i and last run %i ..", g:xolox#misc#version, function, interval, last_run)
строка 11, команда     " Rate limit in case &updatetime is set (very) low.
строка 12, команда     let time_until_next_run = (last_run + interval) - localtime()
строка 13, команда     if time_until_next_run > 0
строка 14, команда       call xolox#misc#msg#debug("vim-misc %s: Rate limiting handler %s (time until next run: %i seconds).", g:xolox#misc#version, function, time_until_next_run)
строка 15, команда     else
строка 16, команда       call xolox#misc#msg#debug("vim-misc %s: Running handler %s ..", g:xolox#misc#version, function)
строка 17, команда       call call(function, get(handler, 'arguments', []))
строка 18, команда       let handler['last_run'] = localtime()
строка 19, команда     endif
строка 20, команда   endfor
xolox#misc#cursorhold#autocmd вернула #0

Начинается обработка для события CursorHold автокоманды "*"

Выполнение для события BufLeave автокоманды "*"
автокоманда if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif

Выполнение if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
Выполнение let w:netrw_prvfile= expand("%:p")|endif
Выполнение endif
Выполнение для события WinLeave автокоманды "*"
автокоманда call s:Remove_Matches()

Выполнение call s:Remove_Matches()
вызов <SNR>30_Remove_Matches()

строка 1, команда   if exists('w:paren_hl_on') && w:paren_hl_on
строка 2, команда     silent! call matchdelete(3)
строка 3, команда     let w:paren_hl_on = 0
строка 4, команда   endif
<SNR>30_Remove_Matches вернула #0

Начинается обработка для события WinLeave автокоманды "*"

Выполнение для события WinEnter автокоманды "*"
автокоманда call s:Highlight_Matching_Pair()

Выполнение call s:Highlight_Matching_Pair()
вызов <SNR>30_Highlight_Matching_Pair()

строка 1, команда   " Remove any previous match.
строка 2, команда   call s:Remove_Matches()
вызов <SNR>30_Remove_Matches()

строка 1, команда   if exists('w:paren_hl_on') && w:paren_hl_on
строка 2, команда     silent! call matchdelete(3)
строка 3, команда     let w:paren_hl_on = 0
строка 4, команда   endif
<SNR>30_Remove_Matches вернула #0

Начинается обработка <SNR>30_Highlight_Matching_Pair

строка 3, команда 
строка 4, команда   " Avoid that we remove the popup menu.
строка 5, команда   " Return when there are no colors (looks like the cursor jumps).
строка 6, команда   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
строка 7, команда     return
строка 8, команда   endif
строка 9, команда 
строка 10, команда   " Get the character under the cursor and check if it's in 'matchpairs'.
строка 11, команда   let c_lnum = line('.')
строка 12, команда   let c_col = col('.')
строка 13, команда   let before = 0
строка 14, команда 
строка 15, команда   let text = getline(c_lnum)
строка 16, команда   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
строка 17, команда   if empty(matches)
строка 18, команда     let [c_before, c] = ['', '']
строка 19, команда   else
строка 20, команда     let [c_before, c] = matches[1:2]
строка 21, команда   endif
строка 22, команда   let plist = split(&matchpairs, '.\zs[:,]')
строка 23, команда   let i = index(plist, c)
строка 24, команда   if i < 0
строка 25, команда     " not found, in Insert mode try character before the cursor
строка 26, команда     if c_col > 1 && (mode() == 'i' || mode() == 'R')
строка 27, команда       let before = strlen(c_before)
строка 28, команда       let c = c_before
строка 29, команда       let i = index(plist, c)
строка 30, команда     endif
строка 31, команда     if i < 0
строка 32, команда       " not found, nothing to do
строка 33, команда       return
строка 34, команда     endif
строка 35, команда   endif
строка 36, команда 
строка 37, команда   " Figure out the arguments for searchpairpos().
строка 38, команда   if i % 2 == 0
строка 39, команда     let s_flags = 'nW'
строка 40, команда     let c2 = plist[i + 1]
строка 41, команда   else
строка 42, команда     let s_flags = 'nbW'
строка 43, команда     let c2 = c
строка 44, команда     let c = plist[i - 1]
строка 45, команда   endif
строка 46, команда   if c == '['
строка 47, команда     let c = '\['
строка 48, команда     let c2 = '\]'
строка 49, команда   endif
строка 50, команда 
строка 51, команда   " Find the match.  When it was just before the cursor move it there for a
строка 52, команда   " moment.
строка 53, команда   if before > 0
строка 54, команда     let has_getcurpos = exists("*getcurpos")
строка 55, команда     if has_getcurpos
строка 56, команда       " getcurpos() is more efficient but doesn't exist before 7.4.313.
строка 57, команда       let save_cursor = getcurpos()
строка 58, команда     else
строка 59, команда       let save_cursor = winsaveview()
строка 60, команда     endif
строка 61, команда     call cursor(c_lnum, c_col - before)
строка 62, команда   endif
строка 63, команда 
строка 64, команда   if !has("syntax") || !exists("g:syntax_on")
строка 65, команда     let s_skip = "0"
строка 66, команда   else
строка 67, команда     " Build an expression that detects whether the current cursor position is
строка 68, команда     " in certain syntax types (string, comment, etc.), for use as
строка 69, команда     " searchpairpos()'s skip argument.
строка 70, команда     " We match "escape" for special items, such as lispEscapeSpecial, and
строка 71, команда     " match "symbol" for lispBarSymbol.
строка 72, команда     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
строка 74, команда     " If executing the expression determines that the cursor is currently in
строка 75, команда     " one of the syntax types, then we want searchpairpos() to find the pair
строка 76, команда     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
строка 77, команда     " outside of the syntax types and s_skip should keep its value so we skip
строка 78, команда     " any matching pair inside the syntax types.
строка 79, команда     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
строка 80, команда     try
строка 81, команда       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
строка 81, команда if !empty(filter(map(synstack(line("."), col(".")), 'synIDattr(v:val, "name")'), 'v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"')) | let s_skip = "0" | endif
строка 81, команда  let s_skip = "0" | endif
строка 81, команда  endif
строка 82, команда     catch /^Vim\%((\a\+)\)\=:E363/
строка 83, команда       " We won't find anything, so skip searching, should keep Vim responsive.
строка 84, команда       return
строка 85, команда     endtry
строка 86, команда   endif
строка 87, команда 
строка 88, команда   " Limit the search to lines visible in the window.
строка 89, команда   let stoplinebottom = line('w$')
строка 90, команда   let stoplinetop = line('w0')
строка 91, команда   if i % 2 == 0
строка 92, команда     let stopline = stoplinebottom
строка 93, команда   else
строка 94, команда     let stopline = stoplinetop
строка 95, команда   endif
строка 96, команда 
строка 97, команда   " Limit the search time to 300 msec to avoid a hang on very long lines.
строка 98, команда   " This fails when a timeout is not supported.
строка 99, команда   if mode() == 'i' || mode() == 'R'
строка 100, команда     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
строка 101, команда   else
строка 102, команда     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
строка 103, команда   endif
строка 104, команда   try
строка 105, команда     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
строка 106, команда   catch /E118/
строка 107, команда     " Can't use the timeout, restrict the stopline a bit more to avoid taking
строка 108, команда     " a long time on closed folds and long lines.
строка 109, команда     " The "viewable" variables give a range in which we can scroll while
строка 110, команда     " keeping the cursor at the same position.
строка 111, команда     " adjustedScrolloff accounts for very large numbers of scrolloff.
строка 112, команда     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
строка 113, команда     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
строка 114, команда     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
строка 115, команда     " one of these stoplines will be adjusted below, but the current values are
строка 116, команда     " minimal boundaries within the current window
строка 117, команда     if i % 2 == 0
строка 118, команда       if has("byte_offset") && has("syntax_items") && &smc > 0
строка 119, команда ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
строка 120, команда ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
строка 121, команда       else
строка 122, команда ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
строка 123, команда       endif
строка 124, команда       let stoplinebottom = stopline
строка 125, команда     else
строка 126, команда       if has("byte_offset") && has("syntax_items") && &smc > 0
строка 127, команда ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
строка 128, команда ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
строка 129, команда       else
строка 130, команда ^Ilet stopline = max([top_viewable, c_lnum - 100])
строка 131, команда       endif
строка 132, команда       let stoplinetop = stopline
строка 133, команда     endif
строка 134, команда     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
строка 135, команда   endtry
строка 136, команда 
строка 137, команда   if before > 0
строка 138, команда     if has_getcurpos
строка 139, команда       call setpos('.', save_cursor)
строка 140, команда     else
строка 141, команда       call winrestview(save_cursor)
строка 142, команда     endif
строка 143, команда   endif
строка 144, команда 
строка 145, команда   " If a match is found setup match highlighting.
строка 146, команда   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
строка 147, команда     if exists('*matchaddpos')
строка 148, команда       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
строка 149, команда     else
строка 150, команда       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
строка 152, команда     endif
строка 153, команда     let w:paren_hl_on = 1
строка 154, команда   endif
<SNR>30_Highlight_Matching_Pair вернула #0

Начинается обработка для события WinEnter автокоманды "*"

Выполнение для события BufEnter автокоманды "*"
автокоманда sil call s:LocalBrowse(expand("<amatch>"))

Выполнение sil call s:LocalBrowse(expand("<amatch>"))
вызов <SNR>31_LocalBrowse('D:/Project/vim/my_plugins/colo2css/Tmp_colo2css')

строка 1, команда   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
строка 2, команда   " Otherwise, the BufEnter event gets triggered when attempts to write to
строка 3, команда   " the DBG buffer are made.
строка 4, команда 
строка 5, команда   if !exists("s:vimentered")
строка 6, команда    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
строка 7, команда    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
строка 8, команда "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
строка 9, команда "   call Dret("s:LocalBrowse")
строка 10, команда    return
строка 11, команда   endif
строка 12, команда 
строка 13, команда "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
строка 14, команда 
строка 15, команда   if has("amiga")
строка 16, команда    " The check against '' is made for the Amiga, where the empty
строка 17, команда    " string is the current directory and not checking would break
строка 18, команда    " things such as the help command.
строка 19, команда "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
строка 20, команда    if a:dirname != '' && isdirectory(a:dirname)
строка 21, команда     sil! call netrw#LocalBrowseCheck(a:dirname)
строка 22, команда     if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
строка 23, команда      exe w:netrw_bannercnt
строка 24, команда     endif
строка 25, команда    endif
строка 26, команда 
строка 27, команда   elseif isdirectory(a:dirname)
строка 28, команда "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
строка 29, команда "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
строка 30, команда    " Jul 13, 2021: for whatever reason, preceding the following call with
строка 31, команда    " a   sil!  causes an unbalanced if-endif vim error
строка 32, команда    call netrw#LocalBrowseCheck(a:dirname)
строка 33, команда    if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
строка 34, команда     exe w:netrw_bannercnt
строка 35, команда    endif
строка 36, команда 
строка 37, команда   else
строка 38, команда    " not a directory, ignore it
строка 39, команда "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
строка 40, команда   endif
строка 41, команда 
строка 42, команда "  call Dret("s:LocalBrowse")
<SNR>31_LocalBrowse вернула #0

Начинается обработка для события BufEnter автокоманды "*"

Выполнение для события CursorMoved автокоманды "*"
автокоманда call s:Highlight_Matching_Pair()

Выполнение call s:Highlight_Matching_Pair()
вызов <SNR>30_Highlight_Matching_Pair()

строка 1, команда   " Remove any previous match.
строка 2, команда   call s:Remove_Matches()
вызов <SNR>30_Remove_Matches()

строка 1, команда   if exists('w:paren_hl_on') && w:paren_hl_on
строка 2, команда     silent! call matchdelete(3)
строка 3, команда     let w:paren_hl_on = 0
строка 4, команда   endif
<SNR>30_Remove_Matches вернула #0

Начинается обработка <SNR>30_Highlight_Matching_Pair

строка 3, команда 
строка 4, команда   " Avoid that we remove the popup menu.
строка 5, команда   " Return when there are no colors (looks like the cursor jumps).
строка 6, команда   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
строка 7, команда     return
строка 8, команда   endif
строка 9, команда 
строка 10, команда   " Get the character under the cursor and check if it's in 'matchpairs'.
строка 11, команда   let c_lnum = line('.')
строка 12, команда   let c_col = col('.')
строка 13, команда   let before = 0
строка 14, команда 
строка 15, команда   let text = getline(c_lnum)
строка 16, команда   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
строка 17, команда   if empty(matches)
строка 18, команда     let [c_before, c] = ['', '']
строка 19, команда   else
строка 20, команда     let [c_before, c] = matches[1:2]
строка 21, команда   endif
строка 22, команда   let plist = split(&matchpairs, '.\zs[:,]')
строка 23, команда   let i = index(plist, c)
строка 24, команда   if i < 0
строка 25, команда     " not found, in Insert mode try character before the cursor
строка 26, команда     if c_col > 1 && (mode() == 'i' || mode() == 'R')
строка 27, команда       let before = strlen(c_before)
строка 28, команда       let c = c_before
строка 29, команда       let i = index(plist, c)
строка 30, команда     endif
строка 31, команда     if i < 0
строка 32, команда       " not found, nothing to do
строка 33, команда       return
строка 34, команда     endif
строка 35, команда   endif
строка 36, команда 
строка 37, команда   " Figure out the arguments for searchpairpos().
строка 38, команда   if i % 2 == 0
строка 39, команда     let s_flags = 'nW'
строка 40, команда     let c2 = plist[i + 1]
строка 41, команда   else
строка 42, команда     let s_flags = 'nbW'
строка 43, команда     let c2 = c
строка 44, команда     let c = plist[i - 1]
строка 45, команда   endif
строка 46, команда   if c == '['
строка 47, команда     let c = '\['
строка 48, команда     let c2 = '\]'
строка 49, команда   endif
строка 50, команда 
строка 51, команда   " Find the match.  When it was just before the cursor move it there for a
строка 52, команда   " moment.
строка 53, команда   if before > 0
строка 54, команда     let has_getcurpos = exists("*getcurpos")
строка 55, команда     if has_getcurpos
строка 56, команда       " getcurpos() is more efficient but doesn't exist before 7.4.313.
строка 57, команда       let save_cursor = getcurpos()
строка 58, команда     else
строка 59, команда       let save_cursor = winsaveview()
строка 60, команда     endif
строка 61, команда     call cursor(c_lnum, c_col - before)
строка 62, команда   endif
строка 63, команда 
строка 64, команда   if !has("syntax") || !exists("g:syntax_on")
строка 65, команда     let s_skip = "0"
строка 66, команда   else
строка 67, команда     " Build an expression that detects whether the current cursor position is
строка 68, команда     " in certain syntax types (string, comment, etc.), for use as
строка 69, команда     " searchpairpos()'s skip argument.
строка 70, команда     " We match "escape" for special items, such as lispEscapeSpecial, and
строка 71, команда     " match "symbol" for lispBarSymbol.
строка 72, команда     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
строка 74, команда     " If executing the expression determines that the cursor is currently in
строка 75, команда     " one of the syntax types, then we want searchpairpos() to find the pair
строка 76, команда     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
строка 77, команда     " outside of the syntax types and s_skip should keep its value so we skip
строка 78, команда     " any matching pair inside the syntax types.
строка 79, команда     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
строка 80, команда     try
строка 81, команда       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
строка 81, команда if !empty(filter(map(synstack(line("."), col(".")), 'synIDattr(v:val, "name")'), 'v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"')) | let s_skip = "0" | endif
строка 81, команда  let s_skip = "0" | endif
строка 81, команда  endif
строка 82, команда     catch /^Vim\%((\a\+)\)\=:E363/
строка 83, команда       " We won't find anything, so skip searching, should keep Vim responsive.
строка 84, команда       return
строка 85, команда     endtry
строка 86, команда   endif
строка 87, команда 
строка 88, команда   " Limit the search to lines visible in the window.
строка 89, команда   let stoplinebottom = line('w$')
строка 90, команда   let stoplinetop = line('w0')
строка 91, команда   if i % 2 == 0
строка 92, команда     let stopline = stoplinebottom
строка 93, команда   else
строка 94, команда     let stopline = stoplinetop
строка 95, команда   endif
строка 96, команда 
строка 97, команда   " Limit the search time to 300 msec to avoid a hang on very long lines.
строка 98, команда   " This fails when a timeout is not supported.
строка 99, команда   if mode() == 'i' || mode() == 'R'
строка 100, команда     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
строка 101, команда   else
строка 102, команда     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
строка 103, команда   endif
строка 104, команда   try
строка 105, команда     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
строка 106, команда   catch /E118/
строка 107, команда     " Can't use the timeout, restrict the stopline a bit more to avoid taking
строка 108, команда     " a long time on closed folds and long lines.
строка 109, команда     " The "viewable" variables give a range in which we can scroll while
строка 110, команда     " keeping the cursor at the same position.
строка 111, команда     " adjustedScrolloff accounts for very large numbers of scrolloff.
строка 112, команда     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
строка 113, команда     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
строка 114, команда     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
строка 115, команда     " one of these stoplines will be adjusted below, but the current values are
строка 116, команда     " minimal boundaries within the current window
строка 117, команда     if i % 2 == 0
строка 118, команда       if has("byte_offset") && has("syntax_items") && &smc > 0
строка 119, команда ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
строка 120, команда ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
строка 121, команда       else
строка 122, команда ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
строка 123, команда       endif
строка 124, команда       let stoplinebottom = stopline
строка 125, команда     else
строка 126, команда       if has("byte_offset") && has("syntax_items") && &smc > 0
строка 127, команда ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
строка 128, команда ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
строка 129, команда       else
строка 130, команда ^Ilet stopline = max([top_viewable, c_lnum - 100])
строка 131, команда       endif
строка 132, команда       let stoplinetop = stopline
строка 133, команда     endif
строка 134, команда     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
строка 135, команда   endtry
строка 136, команда 
строка 137, команда   if before > 0
строка 138, команда     if has_getcurpos
строка 139, команда       call setpos('.', save_cursor)
строка 140, команда     else
строка 141, команда       call winrestview(save_cursor)
строка 142, команда     endif
строка 143, команда   endif
строка 144, команда 
строка 145, команда   " If a match is found setup match highlighting.
строка 146, команда   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
строка 147, команда     if exists('*matchaddpos')
строка 148, команда       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
строка 149, команда     else
строка 150, команда       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
строка 152, команда     endif
строка 153, команда     let w:paren_hl_on = 1
строка 154, команда   endif
<SNR>30_Highlight_Matching_Pair вернула #0

Начинается обработка для события CursorMoved автокоманды "*"

Выполнение для события CursorHold автокоманды "*"
автокоманда call xolox#misc#cursorhold#autocmd()

Выполнение call xolox#misc#cursorhold#autocmd()
вызов xolox#misc#cursorhold#autocmd()

строка 1, команда   " The 'top level event handler' that's called by Vim whenever the
строка 2, команда   " [CursorHold][] or [CursorHoldI][] event fires. It iterates through the
строка 3, команда   " event handlers registered using `xolox#misc#cursorhold#register()` and
строка 4, команда   " calls each event handler at the appropriate interval, keeping track of
строка 5, команда   " the time when each event handler was last run.
строка 6, команда   for handler in g:xolox#misc#cursorhold#handlers
строка 7, команда     let function = handler['function']
строка 8, команда     let last_run = get(handler, 'last_run', 0)
строка 9, команда     let interval = get(handler, 'interval', 4)
строка 10, команда     call xolox#misc#msg#debug("vim-misc %s: Checking handler %s with interval %i and last run %i ..", g:xolox#misc#version, function, interval, last_run)
строка 11, команда     " Rate limit in case &updatetime is set (very) low.
строка 12, команда     let time_until_next_run = (last_run + interval) - localtime()
строка 13, команда     if time_until_next_run > 0
строка 14, команда       call xolox#misc#msg#debug("vim-misc %s: Rate limiting handler %s (time until next run: %i seconds).", g:xolox#misc#version, function, time_until_next_run)
строка 15, команда     else
строка 16, команда       call xolox#misc#msg#debug("vim-misc %s: Running handler %s ..", g:xolox#misc#version, function)
строка 17, команда       call call(function, get(handler, 'arguments', []))
строка 18, команда       let handler['last_run'] = localtime()
строка 19, команда     endif
строка 20, команда   endfor
xolox#misc#cursorhold#autocmd вернула #0

Начинается обработка для события CursorHold автокоманды "*"

Выполнение для события BufLeave автокоманды "*"
автокоманда if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif

Выполнение if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
Выполнение let w:netrw_prvfile= expand("%:p")|endif
Выполнение endif
Выполнение для события WinLeave автокоманды "*"
автокоманда call s:Remove_Matches()

Выполнение call s:Remove_Matches()
вызов <SNR>30_Remove_Matches()

строка 1, команда   if exists('w:paren_hl_on') && w:paren_hl_on
строка 2, команда     silent! call matchdelete(3)
строка 3, команда     let w:paren_hl_on = 0
строка 4, команда   endif
<SNR>30_Remove_Matches вернула #0

Начинается обработка для события WinLeave автокоманды "*"

Выполнение для события WinEnter автокоманды "*"
автокоманда call s:Highlight_Matching_Pair()

Выполнение call s:Highlight_Matching_Pair()
вызов <SNR>30_Highlight_Matching_Pair()

строка 1, команда   " Remove any previous match.
строка 2, команда   call s:Remove_Matches()
вызов <SNR>30_Remove_Matches()

строка 1, команда   if exists('w:paren_hl_on') && w:paren_hl_on
строка 2, команда     silent! call matchdelete(3)
строка 3, команда     let w:paren_hl_on = 0
строка 4, команда   endif
<SNR>30_Remove_Matches вернула #0

Начинается обработка <SNR>30_Highlight_Matching_Pair

строка 3, команда 
строка 4, команда   " Avoid that we remove the popup menu.
строка 5, команда   " Return when there are no colors (looks like the cursor jumps).
строка 6, команда   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
строка 7, команда     return
строка 8, команда   endif
строка 9, команда 
строка 10, команда   " Get the character under the cursor and check if it's in 'matchpairs'.
строка 11, команда   let c_lnum = line('.')
строка 12, команда   let c_col = col('.')
строка 13, команда   let before = 0
строка 14, команда 
строка 15, команда   let text = getline(c_lnum)
строка 16, команда   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
строка 17, команда   if empty(matches)
строка 18, команда     let [c_before, c] = ['', '']
строка 19, команда   else
строка 20, команда     let [c_before, c] = matches[1:2]
строка 21, команда   endif
строка 22, команда   let plist = split(&matchpairs, '.\zs[:,]')
строка 23, команда   let i = index(plist, c)
строка 24, команда   if i < 0
строка 25, команда     " not found, in Insert mode try character before the cursor
строка 26, команда     if c_col > 1 && (mode() == 'i' || mode() == 'R')
строка 27, команда       let before = strlen(c_before)
строка 28, команда       let c = c_before
строка 29, команда       let i = index(plist, c)
строка 30, команда     endif
строка 31, команда     if i < 0
строка 32, команда       " not found, nothing to do
строка 33, команда       return
<SNR>30_Highlight_Matching_Pair вернула #0

Начинается обработка для события WinEnter автокоманды "*"

Выполнение для события BufEnter автокоманды "*"
автокоманда sil call s:LocalBrowse(expand("<amatch>"))

Выполнение sil call s:LocalBrowse(expand("<amatch>"))
вызов <SNR>31_LocalBrowse('D:/Project/vim/my_plugins/colo2css/colo2css.vim')

строка 1, команда   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
строка 2, команда   " Otherwise, the BufEnter event gets triggered when attempts to write to
строка 3, команда   " the DBG buffer are made.
строка 4, команда 
строка 5, команда   if !exists("s:vimentered")
строка 6, команда    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
строка 7, команда    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
строка 8, команда "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
строка 9, команда "   call Dret("s:LocalBrowse")
строка 10, команда    return
строка 11, команда   endif
строка 12, команда 
строка 13, команда "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
строка 14, команда 
строка 15, команда   if has("amiga")
строка 16, команда    " The check against '' is made for the Amiga, where the empty
строка 17, команда    " string is the current directory and not checking would break
строка 18, команда    " things such as the help command.
строка 19, команда "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
строка 20, команда    if a:dirname != '' && isdirectory(a:dirname)
строка 21, команда     sil! call netrw#LocalBrowseCheck(a:dirname)
строка 22, команда     if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
строка 23, команда      exe w:netrw_bannercnt
строка 24, команда     endif
строка 25, команда    endif
строка 26, команда 
строка 27, команда   elseif isdirectory(a:dirname)
строка 28, команда "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
строка 29, команда "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
строка 30, команда    " Jul 13, 2021: for whatever reason, preceding the following call with
строка 31, команда    " a   sil!  causes an unbalanced if-endif vim error
строка 32, команда    call netrw#LocalBrowseCheck(a:dirname)
строка 33, команда    if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
строка 34, команда     exe w:netrw_bannercnt
строка 35, команда    endif
строка 36, команда 
строка 37, команда   else
строка 38, команда    " not a directory, ignore it
строка 39, команда "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
строка 40, команда   endif
строка 41, команда 
строка 42, команда "  call Dret("s:LocalBrowse")
<SNR>31_LocalBrowse вернула #0

Начинается обработка для события BufEnter автокоманды "*"

Выполнение для события CursorMoved автокоманды "*"
автокоманда call s:Highlight_Matching_Pair()

Выполнение call s:Highlight_Matching_Pair()
вызов <SNR>30_Highlight_Matching_Pair()

строка 1, команда   " Remove any previous match.
строка 2, команда   call s:Remove_Matches()
вызов <SNR>30_Remove_Matches()

строка 1, команда   if exists('w:paren_hl_on') && w:paren_hl_on
строка 2, команда     silent! call matchdelete(3)
строка 3, команда     let w:paren_hl_on = 0
строка 4, команда   endif
<SNR>30_Remove_Matches вернула #0

Начинается обработка <SNR>30_Highlight_Matching_Pair

строка 3, команда 
строка 4, команда   " Avoid that we remove the popup menu.
строка 5, команда   " Return when there are no colors (looks like the cursor jumps).
строка 6, команда   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
строка 7, команда     return
строка 8, команда   endif
строка 9, команда 
строка 10, команда   " Get the character under the cursor and check if it's in 'matchpairs'.
строка 11, команда   let c_lnum = line('.')
строка 12, команда   let c_col = col('.')
строка 13, команда   let before = 0
строка 14, команда 
строка 15, команда   let text = getline(c_lnum)
строка 16, команда   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
строка 17, команда   if empty(matches)
строка 18, команда     let [c_before, c] = ['', '']
строка 19, команда   else
строка 20, команда     let [c_before, c] = matches[1:2]
строка 21, команда   endif
строка 22, команда   let plist = split(&matchpairs, '.\zs[:,]')
строка 23, команда   let i = index(plist, c)
строка 24, команда   if i < 0
строка 25, команда     " not found, in Insert mode try character before the cursor
строка 26, команда     if c_col > 1 && (mode() == 'i' || mode() == 'R')
строка 27, команда       let before = strlen(c_before)
строка 28, команда       let c = c_before
строка 29, команда       let i = index(plist, c)
строка 30, команда     endif
строка 31, команда     if i < 0
строка 32, команда       " not found, nothing to do
строка 33, команда       return
<SNR>30_Highlight_Matching_Pair вернула #0

Начинается обработка для события CursorMoved автокоманды "*"

Выполнение для события BufLeave автокоманды "*"
автокоманда if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif

Выполнение if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
Выполнение let w:netrw_prvfile= expand("%:p")|endif
Выполнение endif
Выполнение для события WinLeave автокоманды "*"
автокоманда call s:Remove_Matches()

Выполнение call s:Remove_Matches()
вызов <SNR>30_Remove_Matches()

строка 1, команда   if exists('w:paren_hl_on') && w:paren_hl_on
строка 2, команда     silent! call matchdelete(3)
строка 3, команда     let w:paren_hl_on = 0
строка 4, команда   endif
<SNR>30_Remove_Matches вернула #0

Начинается обработка для события WinLeave автокоманды "*"

Выполнение для события WinEnter автокоманды "*"
автокоманда call s:Highlight_Matching_Pair()

Выполнение call s:Highlight_Matching_Pair()
вызов <SNR>30_Highlight_Matching_Pair()

строка 1, команда   " Remove any previous match.
строка 2, команда   call s:Remove_Matches()
вызов <SNR>30_Remove_Matches()

строка 1, команда   if exists('w:paren_hl_on') && w:paren_hl_on
строка 2, команда     silent! call matchdelete(3)
строка 3, команда     let w:paren_hl_on = 0
строка 4, команда   endif
<SNR>30_Remove_Matches вернула #0

Начинается обработка <SNR>30_Highlight_Matching_Pair

строка 3, команда 
строка 4, команда   " Avoid that we remove the popup menu.
строка 5, команда   " Return when there are no colors (looks like the cursor jumps).
строка 6, команда   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
строка 7, команда     return
строка 8, команда   endif
строка 9, команда 
строка 10, команда   " Get the character under the cursor and check if it's in 'matchpairs'.
строка 11, команда   let c_lnum = line('.')
строка 12, команда   let c_col = col('.')
строка 13, команда   let before = 0
строка 14, команда 
строка 15, команда   let text = getline(c_lnum)
строка 16, команда   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
строка 17, команда   if empty(matches)
строка 18, команда     let [c_before, c] = ['', '']
строка 19, команда   else
строка 20, команда     let [c_before, c] = matches[1:2]
строка 21, команда   endif
строка 22, команда   let plist = split(&matchpairs, '.\zs[:,]')
строка 23, команда   let i = index(plist, c)
строка 24, команда   if i < 0
строка 25, команда     " not found, in Insert mode try character before the cursor
строка 26, команда     if c_col > 1 && (mode() == 'i' || mode() == 'R')
строка 27, команда       let before = strlen(c_before)
строка 28, команда       let c = c_before
строка 29, команда       let i = index(plist, c)
строка 30, команда     endif
строка 31, команда     if i < 0
строка 32, команда       " not found, nothing to do
строка 33, команда       return
<SNR>30_Highlight_Matching_Pair вернула #0

Начинается обработка для события WinEnter автокоманды "*"

Выполнение для события BufEnter автокоманды "*"
автокоманда sil call s:LocalBrowse(expand("<amatch>"))

Выполнение sil call s:LocalBrowse(expand("<amatch>"))
вызов <SNR>31_LocalBrowse('D:/Project/vim/my_plugins/colo2css/HiAttr2CssDecl.vim')

строка 1, команда   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
строка 2, команда   " Otherwise, the BufEnter event gets triggered when attempts to write to
строка 3, команда   " the DBG buffer are made.
строка 4, команда 
строка 5, команда   if !exists("s:vimentered")
строка 6, команда    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
строка 7, команда    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
строка 8, команда "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
строка 9, команда "   call Dret("s:LocalBrowse")
строка 10, команда    return
строка 11, команда   endif
строка 12, команда 
строка 13, команда "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
строка 14, команда 
строка 15, команда   if has("amiga")
строка 16, команда    " The check against '' is made for the Amiga, where the empty
строка 17, команда    " string is the current directory and not checking would break
строка 18, команда    " things such as the help command.
строка 19, команда "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
строка 20, команда    if a:dirname != '' && isdirectory(a:dirname)
строка 21, команда     sil! call netrw#LocalBrowseCheck(a:dirname)
строка 22, команда     if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
строка 23, команда      exe w:netrw_bannercnt
строка 24, команда     endif
строка 25, команда    endif
строка 26, команда 
строка 27, команда   elseif isdirectory(a:dirname)
строка 28, команда "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
строка 29, команда "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
строка 30, команда    " Jul 13, 2021: for whatever reason, preceding the following call with
строка 31, команда    " a   sil!  causes an unbalanced if-endif vim error
строка 32, команда    call netrw#LocalBrowseCheck(a:dirname)
строка 33, команда    if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
строка 34, команда     exe w:netrw_bannercnt
строка 35, команда    endif
строка 36, команда 
строка 37, команда   else
строка 38, команда    " not a directory, ignore it
строка 39, команда "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
строка 40, команда   endif
строка 41, команда 
строка 42, команда "  call Dret("s:LocalBrowse")
<SNR>31_LocalBrowse вернула #0

Начинается обработка для события BufEnter автокоманды "*"

Выполнение для события CursorMoved автокоманды "*"
автокоманда call s:Highlight_Matching_Pair()

Выполнение call s:Highlight_Matching_Pair()
вызов <SNR>30_Highlight_Matching_Pair()

строка 1, команда   " Remove any previous match.
строка 2, команда   call s:Remove_Matches()
вызов <SNR>30_Remove_Matches()

строка 1, команда   if exists('w:paren_hl_on') && w:paren_hl_on
строка 2, команда     silent! call matchdelete(3)
строка 3, команда     let w:paren_hl_on = 0
строка 4, команда   endif
<SNR>30_Remove_Matches вернула #0

Начинается обработка <SNR>30_Highlight_Matching_Pair

строка 3, команда 
строка 4, команда   " Avoid that we remove the popup menu.
строка 5, команда   " Return when there are no colors (looks like the cursor jumps).
строка 6, команда   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
строка 7, команда     return
строка 8, команда   endif
строка 9, команда 
строка 10, команда   " Get the character under the cursor and check if it's in 'matchpairs'.
строка 11, команда   let c_lnum = line('.')
строка 12, команда   let c_col = col('.')
строка 13, команда   let before = 0
строка 14, команда 
строка 15, команда   let text = getline(c_lnum)
строка 16, команда   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
строка 17, команда   if empty(matches)
строка 18, команда     let [c_before, c] = ['', '']
строка 19, команда   else
строка 20, команда     let [c_before, c] = matches[1:2]
строка 21, команда   endif
строка 22, команда   let plist = split(&matchpairs, '.\zs[:,]')
строка 23, команда   let i = index(plist, c)
строка 24, команда   if i < 0
строка 25, команда     " not found, in Insert mode try character before the cursor
строка 26, команда     if c_col > 1 && (mode() == 'i' || mode() == 'R')
строка 27, команда       let before = strlen(c_before)
строка 28, команда       let c = c_before
строка 29, команда       let i = index(plist, c)
строка 30, команда     endif
строка 31, команда     if i < 0
строка 32, команда       " not found, nothing to do
строка 33, команда       return
<SNR>30_Highlight_Matching_Pair вернула #0

Начинается обработка для события CursorMoved автокоманды "*"

вызов GetVimIndent()

строка 1, команда   let ignorecase_save = &ignorecase
строка 2, команда   try
строка 3, команда     let &ignorecase = 0
строка 4, команда     return GetVimIndentIntern()
вызов GetVimIndentIntern()

строка 1, команда   " Find a non-blank line above the current line.
строка 2, команда   let lnum = prevnonblank(v:lnum - 1)
строка 3, команда 
строка 4, команда   " The previous line, ignoring line continuation
строка 5, команда   let prev_text_end = lnum > 0 ? getline(lnum) : ''
строка 6, команда 
строка 7, команда   " If the current line doesn't start with '\' or '"\ ' and below a line that
строка 8, команда   " starts with '\' or '"\ ', use the indent of the line above it.
строка 9, команда   let cur_text = getline(v:lnum)
строка 10, команда   if cur_text !~ s:lineContPat
строка 11, команда     while lnum > 0 && getline(lnum) =~ s:lineContPat
строка 12, команда       let lnum = lnum - 1
строка 13, команда     endwhile
строка 14, команда   endif
строка 15, команда 
строка 16, команда   " At the start of the file use zero indent.
строка 17, команда   if lnum == 0
строка 18, команда     return 0
строка 19, команда   endif
строка 20, команда 
строка 21, команда   " the start of the previous line, skipping over line continuation
строка 22, команда   let prev_text = getline(lnum)
строка 23, команда   let found_cont = 0
строка 24, команда 
строка 25, команда   " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
строка 26, команда   " and :else.  Add it three times for a line that starts with '\' or '"\ '
строка 27, команда   " after a line that doesn't (or g:vim_indent_cont if it exists).
строка 28, команда   let ind = indent(lnum)
строка 29, команда 
строка 30, команда   " In heredoc indenting works completely differently.
строка 31, команда   if has('syntax_items') 
строка 32, команда     let syn_here = synIDattr(synID(v:lnum, 1, 1), "name")
строка 33, команда     if syn_here =~ 'vimLetHereDocStop'
строка 34, команда       " End of heredoc: use indent of matching start line
строка 35, команда       let lnum = v:lnum - 1
строка 36, команда       while lnum > 0
строка 37, команда ^Ilet attr = synIDattr(synID(lnum, 1, 1), "name")
строка 38, команда ^Iif attr != '' && attr !~ 'vimLetHereDoc'
строка 39, команда ^I  return indent(lnum)
строка 40, команда ^Iendif
строка 41, команда ^Ilet lnum -= 1
строка 42, команда       endwhile
строка 43, команда       return 0
строка 44, команда     endif
строка 45, команда     if syn_here =~ 'vimLetHereDoc'
строка 46, команда       if synIDattr(synID(lnum, 1, 1), "name") !~ 'vimLetHereDoc'
строка 47, команда ^I" First line in heredoc: increase indent
строка 48, команда ^Ireturn ind + shiftwidth()
строка 49, команда       endif
строка 50, команда       " Heredoc continues: no change in indent
строка 51, команда       return ind
строка 52, команда     endif
строка 53, команда   endif
строка 54, команда 
строка 55, команда   if cur_text =~ s:lineContPat && v:lnum > 1 && prev_text !~ s:lineContPat
строка 56, команда     let found_cont = 1
строка 57, команда     if exists("g:vim_indent_cont")
строка 58, команда       let ind = ind + g:vim_indent_cont
строка 59, команда     else
строка 60, команда       let ind = ind + shiftwidth() * 3
строка 61, команда     endif
строка 62, команда   elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
строка 63, команда     let ind = ind + shiftwidth()
строка 64, команда   else
строка 65, команда     " A line starting with :au does not increment/decrement indent.
строка 66, команда     " A { may start a block or a dict.  Assume that when a } follows it's a
строка 67, команда     " terminated dict.
строка 68, команда     if prev_text !~ '^\s*au\%[tocmd]' && prev_text !~ '^\s*{.*}'
строка 69, команда       let i = match(prev_text, '\(^\||\)\s*\(export\s\+\)\?\({\|\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\|finall\%[y]\|fu\%[nction]\|def\|el\%[seif]\)\>\)')
строка 70, команда       if i >= 0
строка 71, команда ^Ilet ind += shiftwidth()
строка 72, команда ^Iif strpart(prev_text, i, 1) == '|' && has('syntax_items') && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
строка 74, команда ^I  let ind -= shiftwidth()
строка 75, команда ^Iendif
строка 76, команда       endif
строка 77, команда     endif
строка 78, команда   endif
строка 79, команда 
строка 80, команда   " If the previous line contains an "end" after a pipe, but not in an ":au"
строка 81, команда   " command.  And not when there is a backslash before the pipe.
строка 82, команда   " And when syntax HL is enabled avoid a match inside a string.
строка 83, команда   let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
строка 84, команда   if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
строка 85, команда     if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
строка 86, команда       let ind = ind - shiftwidth()
строка 87, команда     endif
строка 88, команда   endif
строка 89, команда 
строка 90, команда   " For a line starting with "}" find the matching "{".  If it is at the start
строка 91, команда   " of the line align with it, probably end of a block.
строка 92, команда   " Use the mapped "%" from matchit to find the match, otherwise we may match
строка 93, команда   " a { inside a comment or string.
строка 94, команда   if cur_text =~ '^\s*}'
строка 95, команда     if maparg('%') != ''
строка 96, команда       exe v:lnum
строка 97, команда       silent! normal %
строка 98, команда       if line('.') < v:lnum && getline('.') =~ '^\s*{'
строка 99, команда ^Ilet ind = indent('.')
строка 100, команда       endif
строка 101, команда     else
строка 102, команда       " todo: use searchpair() to find a match
строка 103, команда     endif
строка 104, команда   endif
строка 105, команда 
строка 106, команда   " Below a line starting with "}" find the matching "{".  If it is at the
строка 107, команда   " end of the line we must be below the end of a dictionary.
строка 108, команда   if prev_text =~ '^\s*}'
строка 109, команда     if maparg('%') != ''
строка 110, команда       exe lnum
строка 111, команда       silent! normal %
строка 112, команда       if line('.') == lnum || getline('.') !~ '^\s*{'
строка 113, команда ^Ilet ind = ind - shiftwidth()
строка 114, команда       endif
строка 115, команда     else
строка 116, команда       " todo: use searchpair() to find a match
строка 117, команда     endif
строка 118, команда   endif
строка 119, команда 
строка 120, команда   " Below a line starting with "]" we must be below the end of a list.
строка 121, команда   " Include a "}" and "},} in case a dictionary ends too.
строка 122, команда   if prev_text_end =~ '^\s*\(},\=\s*\)\=]'
строка 123, команда     let ind = ind - shiftwidth()
строка 124, команда   endif
строка 125, команда 
строка 126, команда   let ends_in_comment = has('syntax_items') && synIDattr(synID(lnum, len(getline(lnum)), 1), "name") =~ '\(Comment\|String\)$'
строка 128, команда 
строка 129, команда   " A line ending in "{" or "[" is most likely the start of a dict/list literal,
строка 130, команда   " indent the next line more.  Not for a continuation line or {{{.
строка 131, команда   if !ends_in_comment && prev_text_end =~ '\s[{[]\s*$' && !found_cont
строка 132, команда     let ind = ind + shiftwidth()
строка 133, команда   endif
строка 134, команда 
строка 135, команда   " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
строка 136, команда   " :endfun, :enddef, :else and :augroup END.
строка 137, команда   if cur_text =~ '^\s*\(ene\@!\|cat\|finall\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
строка 138, команда     let ind = ind - shiftwidth()
строка 139, команда   endif
строка 140, команда 
строка 141, команда   return ind
GetVimIndentIntern вернула #0

Начинается обработка GetVimIndent

:return 0 приостановлено

строка 5, команда   finally
строка 6, команда     let &ignorecase = ignorecase_save
строка 7, команда   endtry
:return 0 возобновлено

GetVimIndent вернула #0
-- РЕЖИМ ВСТАВКИ --
Выполнение для события CursorMovedI автокоманды "*"
автокоманда call s:Highlight_Matching_Pair()

Выполнение call s:Highlight_Matching_Pair()
вызов <SNR>30_Highlight_Matching_Pair()

строка 1, команда   " Remove any previous match.
строка 2, команда   call s:Remove_Matches()
вызов <SNR>30_Remove_Matches()

строка 1, команда   if exists('w:paren_hl_on') && w:paren_hl_on
строка 2, команда     silent! call matchdelete(3)
строка 3, команда     let w:paren_hl_on = 0
строка 4, команда   endif
<SNR>30_Remove_Matches вернула #0

Начинается обработка <SNR>30_Highlight_Matching_Pair

строка 3, команда 
строка 4, команда   " Avoid that we remove the popup menu.
строка 5, команда   " Return when there are no colors (looks like the cursor jumps).
строка 6, команда   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
строка 7, команда     return
строка 8, команда   endif
строка 9, команда 
строка 10, команда   " Get the character under the cursor and check if it's in 'matchpairs'.
строка 11, команда   let c_lnum = line('.')
строка 12, команда   let c_col = col('.')
строка 13, команда   let before = 0
строка 14, команда 
строка 15, команда   let text = getline(c_lnum)
строка 16, команда   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
строка 17, команда   if empty(matches)
строка 18, команда     let [c_before, c] = ['', '']
строка 19, команда   else
строка 20, команда     let [c_before, c] = matches[1:2]
строка 21, команда   endif
строка 22, команда   let plist = split(&matchpairs, '.\zs[:,]')
строка 23, команда   let i = index(plist, c)
строка 24, команда   if i < 0
строка 25, команда     " not found, in Insert mode try character before the cursor
строка 26, команда     if c_col > 1 && (mode() == 'i' || mode() == 'R')
строка 27, команда       let before = strlen(c_before)
строка 28, команда       let c = c_before
строка 29, команда       let i = index(plist, c)
строка 30, команда     endif
строка 31, команда     if i < 0
строка 32, команда       " not found, nothing to do
строка 33, команда       return
<SNR>30_Highlight_Matching_Pair вернула #0

Начинается обработка для события CursorMovedI автокоманды "*"

Выполнение для события TextChangedI автокоманды "*"
автокоманда call s:Highlight_Matching_Pair()

Выполнение call s:Highlight_Matching_Pair()
вызов <SNR>30_Highlight_Matching_Pair()

строка 1, команда   " Remove any previous match.
строка 2, команда   call s:Remove_Matches()
вызов <SNR>30_Remove_Matches()

строка 1, команда   if exists('w:paren_hl_on') && w:paren_hl_on
строка 2, команда     silent! call matchdelete(3)
строка 3, команда     let w:paren_hl_on = 0
строка 4, команда   endif
<SNR>30_Remove_Matches вернула #0

Начинается обработка <SNR>30_Highlight_Matching_Pair

строка 3, команда 
строка 4, команда   " Avoid that we remove the popup menu.
строка 5, команда   " Return when there are no colors (looks like the cursor jumps).
строка 6, команда   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
строка 7, команда     return
строка 8, команда   endif
строка 9, команда 
строка 10, команда   " Get the character under the cursor and check if it's in 'matchpairs'.
строка 11, команда   let c_lnum = line('.')
строка 12, команда   let c_col = col('.')
строка 13, команда   let before = 0
строка 14, команда 
строка 15, команда   let text = getline(c_lnum)
строка 16, команда   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
строка 17, команда   if empty(matches)
строка 18, команда     let [c_before, c] = ['', '']
строка 19, команда   else
строка 20, команда     let [c_before, c] = matches[1:2]
строка 21, команда   endif
строка 22, команда   let plist = split(&matchpairs, '.\zs[:,]')
строка 23, команда   let i = index(plist, c)
строка 24, команда   if i < 0
строка 25, команда     " not found, in Insert mode try character before the cursor
строка 26, команда     if c_col > 1 && (mode() == 'i' || mode() == 'R')
строка 27, команда       let before = strlen(c_before)
строка 28, команда       let c = c_before
строка 29, команда       let i = index(plist, c)
строка 30, команда     endif
строка 31, команда     if i < 0
строка 32, команда       " not found, nothing to do
строка 33, команда       return
<SNR>30_Highlight_Matching_Pair вернула #0

Начинается обработка для события TextChangedI автокоманды "*"

вызов GetVimIndent()

строка 1, команда   let ignorecase_save = &ignorecase
строка 2, команда   try
строка 3, команда     let &ignorecase = 0
строка 4, команда     return GetVimIndentIntern()
вызов GetVimIndentIntern()

строка 1, команда   " Find a non-blank line above the current line.
строка 2, команда   let lnum = prevnonblank(v:lnum - 1)
строка 3, команда 
строка 4, команда   " The previous line, ignoring line continuation
строка 5, команда   let prev_text_end = lnum > 0 ? getline(lnum) : ''
строка 6, команда 
строка 7, команда   " If the current line doesn't start with '\' or '"\ ' and below a line that
строка 8, команда   " starts with '\' or '"\ ', use the indent of the line above it.
строка 9, команда   let cur_text = getline(v:lnum)
строка 10, команда   if cur_text !~ s:lineContPat
строка 11, команда     while lnum > 0 && getline(lnum) =~ s:lineContPat
строка 12, команда       let lnum = lnum - 1
строка 13, команда     endwhile
строка 14, команда   endif
строка 15, команда 
строка 16, команда   " At the start of the file use zero indent.
строка 17, команда   if lnum == 0
строка 18, команда     return 0
строка 19, команда   endif
строка 20, команда 
строка 21, команда   " the start of the previous line, skipping over line continuation
строка 22, команда   let prev_text = getline(lnum)
строка 23, команда   let found_cont = 0
строка 24, команда 
строка 25, команда   " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
строка 26, команда   " and :else.  Add it three times for a line that starts with '\' or '"\ '
строка 27, команда   " after a line that doesn't (or g:vim_indent_cont if it exists).
строка 28, команда   let ind = indent(lnum)
строка 29, команда 
строка 30, команда   " In heredoc indenting works completely differently.
строка 31, команда   if has('syntax_items') 
строка 32, команда     let syn_here = synIDattr(synID(v:lnum, 1, 1), "name")
строка 33, команда     if syn_here =~ 'vimLetHereDocStop'
строка 34, команда       " End of heredoc: use indent of matching start line
строка 35, команда       let lnum = v:lnum - 1
строка 36, команда       while lnum > 0
строка 37, команда ^Ilet attr = synIDattr(synID(lnum, 1, 1), "name")
строка 38, команда ^Iif attr != '' && attr !~ 'vimLetHereDoc'
строка 39, команда ^I  return indent(lnum)
строка 40, команда ^Iendif
строка 41, команда ^Ilet lnum -= 1
строка 42, команда       endwhile
строка 43, команда       return 0
строка 44, команда     endif
строка 45, команда     if syn_here =~ 'vimLetHereDoc'
строка 46, команда       if synIDattr(synID(lnum, 1, 1), "name") !~ 'vimLetHereDoc'
строка 47, команда ^I" First line in heredoc: increase indent
строка 48, команда ^Ireturn ind + shiftwidth()
строка 49, команда       endif
строка 50, команда       " Heredoc continues: no change in indent
строка 51, команда       return ind
строка 52, команда     endif
строка 53, команда   endif
строка 54, команда 
строка 55, команда   if cur_text =~ s:lineContPat && v:lnum > 1 && prev_text !~ s:lineContPat
строка 56, команда     let found_cont = 1
строка 57, команда     if exists("g:vim_indent_cont")
строка 58, команда       let ind = ind + g:vim_indent_cont
строка 59, команда     else
строка 60, команда       let ind = ind + shiftwidth() * 3
строка 61, команда     endif
строка 62, команда   elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
строка 63, команда     let ind = ind + shiftwidth()
строка 64, команда   else
строка 65, команда     " A line starting with :au does not increment/decrement indent.
строка 66, команда     " A { may start a block or a dict.  Assume that when a } follows it's a
строка 67, команда     " terminated dict.
строка 68, команда     if prev_text !~ '^\s*au\%[tocmd]' && prev_text !~ '^\s*{.*}'
строка 69, команда       let i = match(prev_text, '\(^\||\)\s*\(export\s\+\)\?\({\|\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\|finall\%[y]\|fu\%[nction]\|def\|el\%[seif]\)\>\)')
строка 70, команда       if i >= 0
строка 71, команда ^Ilet ind += shiftwidth()
строка 72, команда ^Iif strpart(prev_text, i, 1) == '|' && has('syntax_items') && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
строка 74, команда ^I  let ind -= shiftwidth()
строка 75, команда ^Iendif
строка 76, команда       endif
строка 77, команда     endif
строка 78, команда   endif
строка 79, команда 
строка 80, команда   " If the previous line contains an "end" after a pipe, but not in an ":au"
строка 81, команда   " command.  And not when there is a backslash before the pipe.
строка 82, команда   " And when syntax HL is enabled avoid a match inside a string.
строка 83, команда   let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
строка 84, команда   if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
строка 85, команда     if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
строка 86, команда       let ind = ind - shiftwidth()
строка 87, команда     endif
строка 88, команда   endif
строка 89, команда 
строка 90, команда   " For a line starting with "}" find the matching "{".  If it is at the start
строка 91, команда   " of the line align with it, probably end of a block.
строка 92, команда   " Use the mapped "%" from matchit to find the match, otherwise we may match
строка 93, команда   " a { inside a comment or string.
строка 94, команда   if cur_text =~ '^\s*}'
строка 95, команда     if maparg('%') != ''
строка 96, команда       exe v:lnum
строка 97, команда       silent! normal %
строка 98, команда       if line('.') < v:lnum && getline('.') =~ '^\s*{'
строка 99, команда ^Ilet ind = indent('.')
строка 100, команда       endif
строка 101, команда     else
строка 102, команда       " todo: use searchpair() to find a match
строка 103, команда     endif
строка 104, команда   endif
строка 105, команда 
строка 106, команда   " Below a line starting with "}" find the matching "{".  If it is at the
строка 107, команда   " end of the line we must be below the end of a dictionary.
строка 108, команда   if prev_text =~ '^\s*}'
строка 109, команда     if maparg('%') != ''
строка 110, команда       exe lnum
строка 111, команда       silent! normal %
строка 112, команда       if line('.') == lnum || getline('.') !~ '^\s*{'
строка 113, команда ^Ilet ind = ind - shiftwidth()
строка 114, команда       endif
строка 115, команда     else
строка 116, команда       " todo: use searchpair() to find a match
строка 117, команда     endif
строка 118, команда   endif
строка 119, команда 
строка 120, команда   " Below a line starting with "]" we must be below the end of a list.
строка 121, команда   " Include a "}" and "},} in case a dictionary ends too.
строка 122, команда   if prev_text_end =~ '^\s*\(},\=\s*\)\=]'
строка 123, команда     let ind = ind - shiftwidth()
строка 124, команда   endif
строка 125, команда 
строка 126, команда   let ends_in_comment = has('syntax_items') && synIDattr(synID(lnum, len(getline(lnum)), 1), "name") =~ '\(Comment\|String\)$'
строка 128, команда 
строка 129, команда   " A line ending in "{" or "[" is most likely the start of a dict/list literal,
строка 130, команда   " indent the next line more.  Not for a continuation line or {{{.
строка 131, команда   if !ends_in_comment && prev_text_end =~ '\s[{[]\s*$' && !found_cont
строка 132, команда     let ind = ind + shiftwidth()
строка 133, команда   endif
строка 134, команда 
строка 135, команда   " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
строка 136, команда   " :endfun, :enddef, :else and :augroup END.
строка 137, команда   if cur_text =~ '^\s*\(ene\@!\|cat\|finall\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
строка 138, команда     let ind = ind - shiftwidth()
строка 139, команда   endif
строка 140, команда 
строка 141, команда   return ind
GetVimIndentIntern вернула #0

Начинается обработка GetVimIndent

:return 0 приостановлено

строка 5, команда   finally
строка 6, команда     let &ignorecase = ignorecase_save
строка 7, команда   endtry
:return 0 возобновлено

GetVimIndent вернула #0

Выполнение для события CursorMovedI автокоманды "*"
автокоманда call s:Highlight_Matching_Pair()

Выполнение call s:Highlight_Matching_Pair()
вызов <SNR>30_Highlight_Matching_Pair()

строка 1, команда   " Remove any previous match.
строка 2, команда   call s:Remove_Matches()
вызов <SNR>30_Remove_Matches()

строка 1, команда   if exists('w:paren_hl_on') && w:paren_hl_on
строка 2, команда     silent! call matchdelete(3)
строка 3, команда     let w:paren_hl_on = 0
строка 4, команда   endif
<SNR>30_Remove_Matches вернула #0

Начинается обработка <SNR>30_Highlight_Matching_Pair

строка 3, команда 
строка 4, команда   " Avoid that we remove the popup menu.
строка 5, команда   " Return when there are no colors (looks like the cursor jumps).
строка 6, команда   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
строка 7, команда     return
строка 8, команда   endif
строка 9, команда 
строка 10, команда   " Get the character under the cursor and check if it's in 'matchpairs'.
строка 11, команда   let c_lnum = line('.')
строка 12, команда   let c_col = col('.')
строка 13, команда   let before = 0
строка 14, команда 
строка 15, команда   let text = getline(c_lnum)
строка 16, команда   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
строка 17, команда   if empty(matches)
строка 18, команда     let [c_before, c] = ['', '']
строка 19, команда   else
строка 20, команда     let [c_before, c] = matches[1:2]
строка 21, команда   endif
строка 22, команда   let plist = split(&matchpairs, '.\zs[:,]')
строка 23, команда   let i = index(plist, c)
строка 24, команда   if i < 0
строка 25, команда     " not found, in Insert mode try character before the cursor
строка 26, команда     if c_col > 1 && (mode() == 'i' || mode() == 'R')
строка 27, команда       let before = strlen(c_before)
строка 28, команда       let c = c_before
строка 29, команда       let i = index(plist, c)
строка 30, команда     endif
строка 31, команда     if i < 0
строка 32, команда       " not found, nothing to do
строка 33, команда       return
строка 34, команда     endif
строка 35, команда   endif
строка 36, команда 
строка 37, команда   " Figure out the arguments for searchpairpos().
строка 38, команда   if i % 2 == 0
строка 39, команда     let s_flags = 'nW'
строка 40, команда     let c2 = plist[i + 1]
строка 41, команда   else
строка 42, команда     let s_flags = 'nbW'
строка 43, команда     let c2 = c
строка 44, команда     let c = plist[i - 1]
строка 45, команда   endif
строка 46, команда   if c == '['
строка 47, команда     let c = '\['
строка 48, команда     let c2 = '\]'
строка 49, команда   endif
строка 50, команда 
строка 51, команда   " Find the match.  When it was just before the cursor move it there for a
строка 52, команда   " moment.
строка 53, команда   if before > 0
строка 54, команда     let has_getcurpos = exists("*getcurpos")
строка 55, команда     if has_getcurpos
строка 56, команда       " getcurpos() is more efficient but doesn't exist before 7.4.313.
строка 57, команда       let save_cursor = getcurpos()
строка 58, команда     else
строка 59, команда       let save_cursor = winsaveview()
строка 60, команда     endif
строка 61, команда     call cursor(c_lnum, c_col - before)
строка 62, команда   endif
строка 63, команда 
строка 64, команда   if !has("syntax") || !exists("g:syntax_on")
строка 65, команда     let s_skip = "0"
строка 66, команда   else
строка 67, команда     " Build an expression that detects whether the current cursor position is
строка 68, команда     " in certain syntax types (string, comment, etc.), for use as
строка 69, команда     " searchpairpos()'s skip argument.
строка 70, команда     " We match "escape" for special items, such as lispEscapeSpecial, and
строка 71, команда     " match "symbol" for lispBarSymbol.
строка 72, команда     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
строка 74, команда     " If executing the expression determines that the cursor is currently in
строка 75, команда     " one of the syntax types, then we want searchpairpos() to find the pair
строка 76, команда     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
строка 77, команда     " outside of the syntax types and s_skip should keep its value so we skip
строка 78, команда     " any matching pair inside the syntax types.
строка 79, команда     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
строка 80, команда     try
строка 81, команда       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
строка 81, команда if !empty(filter(map(synstack(line("."), col(".")), 'synIDattr(v:val, "name")'), 'v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"')) | let s_skip = "0" | endif
строка 81, команда  let s_skip = "0" | endif
строка 81, команда  endif
строка 82, команда     catch /^Vim\%((\a\+)\)\=:E363/
строка 83, команда       " We won't find anything, so skip searching, should keep Vim responsive.
строка 84, команда       return
строка 85, команда     endtry
строка 86, команда   endif
строка 87, команда 
строка 88, команда   " Limit the search to lines visible in the window.
строка 89, команда   let stoplinebottom = line('w$')
строка 90, команда   let stoplinetop = line('w0')
строка 91, команда   if i % 2 == 0
строка 92, команда     let stopline = stoplinebottom
строка 93, команда   else
строка 94, команда     let stopline = stoplinetop
строка 95, команда   endif
строка 96, команда 
строка 97, команда   " Limit the search time to 300 msec to avoid a hang on very long lines.
строка 98, команда   " This fails when a timeout is not supported.
строка 99, команда   if mode() == 'i' || mode() == 'R'
строка 100, команда     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
строка 101, команда   else
строка 102, команда     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
строка 103, команда   endif
строка 104, команда   try
строка 105, команда     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
строка 106, команда   catch /E118/
строка 107, команда     " Can't use the timeout, restrict the stopline a bit more to avoid taking
строка 108, команда     " a long time on closed folds and long lines.
строка 109, команда     " The "viewable" variables give a range in which we can scroll while
строка 110, команда     " keeping the cursor at the same position.
строка 111, команда     " adjustedScrolloff accounts for very large numbers of scrolloff.
строка 112, команда     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
строка 113, команда     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
строка 114, команда     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
строка 115, команда     " one of these stoplines will be adjusted below, but the current values are
строка 116, команда     " minimal boundaries within the current window
строка 117, команда     if i % 2 == 0
строка 118, команда       if has("byte_offset") && has("syntax_items") && &smc > 0
строка 119, команда ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
строка 120, команда ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
строка 121, команда       else
строка 122, команда ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
строка 123, команда       endif
строка 124, команда       let stoplinebottom = stopline
строка 125, команда     else
строка 126, команда       if has("byte_offset") && has("syntax_items") && &smc > 0
строка 127, команда ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
строка 128, команда ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
строка 129, команда       else
строка 130, команда ^Ilet stopline = max([top_viewable, c_lnum - 100])
строка 131, команда       endif
строка 132, команда       let stoplinetop = stopline
строка 133, команда     endif
строка 134, команда     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
строка 135, команда   endtry
строка 136, команда 
строка 137, команда   if before > 0
строка 138, команда     if has_getcurpos
строка 139, команда       call setpos('.', save_cursor)
строка 140, команда     else
строка 141, команда       call winrestview(save_cursor)
строка 142, команда     endif
строка 143, команда   endif
строка 144, команда 
строка 145, команда   " If a match is found setup match highlighting.
строка 146, команда   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
строка 147, команда     if exists('*matchaddpos')
строка 148, команда       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
строка 149, команда     else
строка 150, команда       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
строка 152, команда     endif
строка 153, команда     let w:paren_hl_on = 1
строка 154, команда   endif
<SNR>30_Highlight_Matching_Pair вернула #0

Начинается обработка для события CursorMovedI автокоманды "*"

Выполнение для события TextChangedI автокоманды "*"
автокоманда call s:Highlight_Matching_Pair()

Выполнение call s:Highlight_Matching_Pair()
вызов <SNR>30_Highlight_Matching_Pair()

строка 1, команда   " Remove any previous match.
строка 2, команда   call s:Remove_Matches()
вызов <SNR>30_Remove_Matches()

строка 1, команда   if exists('w:paren_hl_on') && w:paren_hl_on
строка 2, команда     silent! call matchdelete(3)
строка 3, команда     let w:paren_hl_on = 0
строка 4, команда   endif
<SNR>30_Remove_Matches вернула #0

Начинается обработка <SNR>30_Highlight_Matching_Pair

строка 3, команда 
строка 4, команда   " Avoid that we remove the popup menu.
строка 5, команда   " Return when there are no colors (looks like the cursor jumps).
строка 6, команда   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
строка 7, команда     return
строка 8, команда   endif
строка 9, команда 
строка 10, команда   " Get the character under the cursor and check if it's in 'matchpairs'.
строка 11, команда   let c_lnum = line('.')
строка 12, команда   let c_col = col('.')
строка 13, команда   let before = 0
строка 14, команда 
строка 15, команда   let text = getline(c_lnum)
строка 16, команда   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
строка 17, команда   if empty(matches)
строка 18, команда     let [c_before, c] = ['', '']
строка 19, команда   else
строка 20, команда     let [c_before, c] = matches[1:2]
строка 21, команда   endif
строка 22, команда   let plist = split(&matchpairs, '.\zs[:,]')
строка 23, команда   let i = index(plist, c)
строка 24, команда   if i < 0
строка 25, команда     " not found, in Insert mode try character before the cursor
строка 26, команда     if c_col > 1 && (mode() == 'i' || mode() == 'R')
строка 27, команда       let before = strlen(c_before)
строка 28, команда       let c = c_before
строка 29, команда       let i = index(plist, c)
строка 30, команда     endif
строка 31, команда     if i < 0
строка 32, команда       " not found, nothing to do
строка 33, команда       return
строка 34, команда     endif
строка 35, команда   endif
строка 36, команда 
строка 37, команда   " Figure out the arguments for searchpairpos().
строка 38, команда   if i % 2 == 0
строка 39, команда     let s_flags = 'nW'
строка 40, команда     let c2 = plist[i + 1]
строка 41, команда   else
строка 42, команда     let s_flags = 'nbW'
строка 43, команда     let c2 = c
строка 44, команда     let c = plist[i - 1]
строка 45, команда   endif
строка 46, команда   if c == '['
строка 47, команда     let c = '\['
строка 48, команда     let c2 = '\]'
строка 49, команда   endif
строка 50, команда 
строка 51, команда   " Find the match.  When it was just before the cursor move it there for a
строка 52, команда   " moment.
строка 53, команда   if before > 0
строка 54, команда     let has_getcurpos = exists("*getcurpos")
строка 55, команда     if has_getcurpos
строка 56, команда       " getcurpos() is more efficient but doesn't exist before 7.4.313.
строка 57, команда       let save_cursor = getcurpos()
строка 58, команда     else
строка 59, команда       let save_cursor = winsaveview()
строка 60, команда     endif
строка 61, команда     call cursor(c_lnum, c_col - before)
строка 62, команда   endif
строка 63, команда 
строка 64, команда   if !has("syntax") || !exists("g:syntax_on")
строка 65, команда     let s_skip = "0"
строка 66, команда   else
строка 67, команда     " Build an expression that detects whether the current cursor position is
строка 68, команда     " in certain syntax types (string, comment, etc.), for use as
строка 69, команда     " searchpairpos()'s skip argument.
строка 70, команда     " We match "escape" for special items, such as lispEscapeSpecial, and
строка 71, команда     " match "symbol" for lispBarSymbol.
строка 72, команда     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
строка 74, команда     " If executing the expression determines that the cursor is currently in
строка 75, команда     " one of the syntax types, then we want searchpairpos() to find the pair
строка 76, команда     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
строка 77, команда     " outside of the syntax types and s_skip should keep its value so we skip
строка 78, команда     " any matching pair inside the syntax types.
строка 79, команда     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
строка 80, команда     try
строка 81, команда       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
строка 81, команда if !empty(filter(map(synstack(line("."), col(".")), 'synIDattr(v:val, "name")'), 'v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"')) | let s_skip = "0" | endif
строка 81, команда  let s_skip = "0" | endif
строка 81, команда  endif
строка 82, команда     catch /^Vim\%((\a\+)\)\=:E363/
строка 83, команда       " We won't find anything, so skip searching, should keep Vim responsive.
строка 84, команда       return
строка 85, команда     endtry
строка 86, команда   endif
строка 87, команда 
строка 88, команда   " Limit the search to lines visible in the window.
строка 89, команда   let stoplinebottom = line('w$')
строка 90, команда   let stoplinetop = line('w0')
строка 91, команда   if i % 2 == 0
строка 92, команда     let stopline = stoplinebottom
строка 93, команда   else
строка 94, команда     let stopline = stoplinetop
строка 95, команда   endif
строка 96, команда 
строка 97, команда   " Limit the search time to 300 msec to avoid a hang on very long lines.
строка 98, команда   " This fails when a timeout is not supported.
строка 99, команда   if mode() == 'i' || mode() == 'R'
строка 100, команда     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
строка 101, команда   else
строка 102, команда     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
строка 103, команда   endif
строка 104, команда   try
строка 105, команда     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
строка 106, команда   catch /E118/
строка 107, команда     " Can't use the timeout, restrict the stopline a bit more to avoid taking
строка 108, команда     " a long time on closed folds and long lines.
строка 109, команда     " The "viewable" variables give a range in which we can scroll while
строка 110, команда     " keeping the cursor at the same position.
строка 111, команда     " adjustedScrolloff accounts for very large numbers of scrolloff.
строка 112, команда     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
строка 113, команда     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
строка 114, команда     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
строка 115, команда     " one of these stoplines will be adjusted below, but the current values are
строка 116, команда     " minimal boundaries within the current window
строка 117, команда     if i % 2 == 0
строка 118, команда       if has("byte_offset") && has("syntax_items") && &smc > 0
строка 119, команда ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
строка 120, команда ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
строка 121, команда       else
строка 122, команда ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
строка 123, команда       endif
строка 124, команда       let stoplinebottom = stopline
строка 125, команда     else
строка 126, команда       if has("byte_offset") && has("syntax_items") && &smc > 0
строка 127, команда ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
строка 128, команда ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
строка 129, команда       else
строка 130, команда ^Ilet stopline = max([top_viewable, c_lnum - 100])
строка 131, команда       endif
строка 132, команда       let stoplinetop = stopline
строка 133, команда     endif
строка 134, команда     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
строка 135, команда   endtry
строка 136, команда 
строка 137, команда   if before > 0
строка 138, команда     if has_getcurpos
строка 139, команда       call setpos('.', save_cursor)
строка 140, команда     else
строка 141, команда       call winrestview(save_cursor)
строка 142, команда     endif
строка 143, команда   endif
строка 144, команда 
строка 145, команда   " If a match is found setup match highlighting.
строка 146, команда   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
строка 147, команда     if exists('*matchaddpos')
строка 148, команда       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
строка 149, команда     else
строка 150, команда       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
строка 152, команда     endif
строка 153, команда     let w:paren_hl_on = 1
строка 154, команда   endif
<SNR>30_Highlight_Matching_Pair вернула #0

Начинается обработка для события TextChangedI автокоманды "*"


Выполнение для события CursorMoved автокоманды "*"
автокоманда call s:Highlight_Matching_Pair()

Выполнение call s:Highlight_Matching_Pair()
вызов <SNR>30_Highlight_Matching_Pair()

строка 1, команда   " Remove any previous match.
строка 2, команда   call s:Remove_Matches()
вызов <SNR>30_Remove_Matches()

строка 1, команда   if exists('w:paren_hl_on') && w:paren_hl_on
строка 2, команда     silent! call matchdelete(3)
строка 3, команда     let w:paren_hl_on = 0
строка 4, команда   endif
<SNR>30_Remove_Matches вернула #0

Начинается обработка <SNR>30_Highlight_Matching_Pair

строка 3, команда 
строка 4, команда   " Avoid that we remove the popup menu.
строка 5, команда   " Return when there are no colors (looks like the cursor jumps).
строка 6, команда   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
строка 7, команда     return
строка 8, команда   endif
строка 9, команда 
строка 10, команда   " Get the character under the cursor and check if it's in 'matchpairs'.
строка 11, команда   let c_lnum = line('.')
строка 12, команда   let c_col = col('.')
строка 13, команда   let before = 0
строка 14, команда 
строка 15, команда   let text = getline(c_lnum)
строка 16, команда   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
строка 17, команда   if empty(matches)
строка 18, команда     let [c_before, c] = ['', '']
строка 19, команда   else
строка 20, команда     let [c_before, c] = matches[1:2]
строка 21, команда   endif
строка 22, команда   let plist = split(&matchpairs, '.\zs[:,]')
строка 23, команда   let i = index(plist, c)
строка 24, команда   if i < 0
строка 25, команда     " not found, in Insert mode try character before the cursor
строка 26, команда     if c_col > 1 && (mode() == 'i' || mode() == 'R')
строка 27, команда       let before = strlen(c_before)
строка 28, команда       let c = c_before
строка 29, команда       let i = index(plist, c)
строка 30, команда     endif
строка 31, команда     if i < 0
строка 32, команда       " not found, nothing to do
строка 33, команда       return
строка 34, команда     endif
строка 35, команда   endif
строка 36, команда 
строка 37, команда   " Figure out the arguments for searchpairpos().
строка 38, команда   if i % 2 == 0
строка 39, команда     let s_flags = 'nW'
строка 40, команда     let c2 = plist[i + 1]
строка 41, команда   else
строка 42, команда     let s_flags = 'nbW'
строка 43, команда     let c2 = c
строка 44, команда     let c = plist[i - 1]
строка 45, команда   endif
строка 46, команда   if c == '['
строка 47, команда     let c = '\['
строка 48, команда     let c2 = '\]'
строка 49, команда   endif
строка 50, команда 
строка 51, команда   " Find the match.  When it was just before the cursor move it there for a
строка 52, команда   " moment.
строка 53, команда   if before > 0
строка 54, команда     let has_getcurpos = exists("*getcurpos")
строка 55, команда     if has_getcurpos
строка 56, команда       " getcurpos() is more efficient but doesn't exist before 7.4.313.
строка 57, команда       let save_cursor = getcurpos()
строка 58, команда     else
строка 59, команда       let save_cursor = winsaveview()
строка 60, команда     endif
строка 61, команда     call cursor(c_lnum, c_col - before)
строка 62, команда   endif
строка 63, команда 
строка 64, команда   if !has("syntax") || !exists("g:syntax_on")
строка 65, команда     let s_skip = "0"
строка 66, команда   else
строка 67, команда     " Build an expression that detects whether the current cursor position is
строка 68, команда     " in certain syntax types (string, comment, etc.), for use as
строка 69, команда     " searchpairpos()'s skip argument.
строка 70, команда     " We match "escape" for special items, such as lispEscapeSpecial, and
строка 71, команда     " match "symbol" for lispBarSymbol.
строка 72, команда     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
строка 74, команда     " If executing the expression determines that the cursor is currently in
строка 75, команда     " one of the syntax types, then we want searchpairpos() to find the pair
строка 76, команда     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
строка 77, команда     " outside of the syntax types and s_skip should keep its value so we skip
строка 78, команда     " any matching pair inside the syntax types.
строка 79, команда     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
строка 80, команда     try
строка 81, команда       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
строка 81, команда if !empty(filter(map(synstack(line("."), col(".")), 'synIDattr(v:val, "name")'), 'v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"')) | let s_skip = "0" | endif
строка 81, команда  let s_skip = "0" | endif
строка 81, команда  endif
строка 82, команда     catch /^Vim\%((\a\+)\)\=:E363/
строка 83, команда       " We won't find anything, so skip searching, should keep Vim responsive.
строка 84, команда       return
строка 85, команда     endtry
строка 86, команда   endif
строка 87, команда 
строка 88, команда   " Limit the search to lines visible in the window.
строка 89, команда   let stoplinebottom = line('w$')
строка 90, команда   let stoplinetop = line('w0')
строка 91, команда   if i % 2 == 0
строка 92, команда     let stopline = stoplinebottom
строка 93, команда   else
строка 94, команда     let stopline = stoplinetop
строка 95, команда   endif
строка 96, команда 
строка 97, команда   " Limit the search time to 300 msec to avoid a hang on very long lines.
строка 98, команда   " This fails when a timeout is not supported.
строка 99, команда   if mode() == 'i' || mode() == 'R'
строка 100, команда     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
строка 101, команда   else
строка 102, команда     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
строка 103, команда   endif
строка 104, команда   try
строка 105, команда     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
строка 106, команда   catch /E118/
строка 107, команда     " Can't use the timeout, restrict the stopline a bit more to avoid taking
строка 108, команда     " a long time on closed folds and long lines.
строка 109, команда     " The "viewable" variables give a range in which we can scroll while
строка 110, команда     " keeping the cursor at the same position.
строка 111, команда     " adjustedScrolloff accounts for very large numbers of scrolloff.
строка 112, команда     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
строка 113, команда     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
строка 114, команда     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
строка 115, команда     " one of these stoplines will be adjusted below, but the current values are
строка 116, команда     " minimal boundaries within the current window
строка 117, команда     if i % 2 == 0
строка 118, команда       if has("byte_offset") && has("syntax_items") && &smc > 0
строка 119, команда ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
строка 120, команда ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
строка 121, команда       else
строка 122, команда ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
строка 123, команда       endif
строка 124, команда       let stoplinebottom = stopline
строка 125, команда     else
строка 126, команда       if has("byte_offset") && has("syntax_items") && &smc > 0
строка 127, команда ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
строка 128, команда ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
строка 129, команда       else
строка 130, команда ^Ilet stopline = max([top_viewable, c_lnum - 100])
строка 131, команда       endif
строка 132, команда       let stoplinetop = stopline
строка 133, команда     endif
строка 134, команда     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
строка 135, команда   endtry
строка 136, команда 
строка 137, команда   if before > 0
строка 138, команда     if has_getcurpos
строка 139, команда       call setpos('.', save_cursor)
строка 140, команда     else
строка 141, команда       call winrestview(save_cursor)
строка 142, команда     endif
строка 143, команда   endif
строка 144, команда 
строка 145, команда   " If a match is found setup match highlighting.
строка 146, команда   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
строка 147, команда     if exists('*matchaddpos')
строка 148, команда       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
строка 149, команда     else
строка 150, команда       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
строка 152, команда     endif
строка 153, команда     let w:paren_hl_on = 1
строка 154, команда   endif
<SNR>30_Highlight_Matching_Pair вернула #0

Начинается обработка для события CursorMoved автокоманды "*"

Выполнение для события TextChanged автокоманды "*"
автокоманда call s:Highlight_Matching_Pair()

Выполнение call s:Highlight_Matching_Pair()
вызов <SNR>30_Highlight_Matching_Pair()

строка 1, команда   " Remove any previous match.
строка 2, команда   call s:Remove_Matches()
вызов <SNR>30_Remove_Matches()

строка 1, команда   if exists('w:paren_hl_on') && w:paren_hl_on
строка 2, команда     silent! call matchdelete(3)
строка 3, команда     let w:paren_hl_on = 0
строка 4, команда   endif
<SNR>30_Remove_Matches вернула #0

Начинается обработка <SNR>30_Highlight_Matching_Pair

строка 3, команда 
строка 4, команда   " Avoid that we remove the popup menu.
строка 5, команда   " Return when there are no colors (looks like the cursor jumps).
строка 6, команда   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
строка 7, команда     return
строка 8, команда   endif
строка 9, команда 
строка 10, команда   " Get the character under the cursor and check if it's in 'matchpairs'.
строка 11, команда   let c_lnum = line('.')
строка 12, команда   let c_col = col('.')
строка 13, команда   let before = 0
строка 14, команда 
строка 15, команда   let text = getline(c_lnum)
строка 16, команда   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
строка 17, команда   if empty(matches)
строка 18, команда     let [c_before, c] = ['', '']
строка 19, команда   else
строка 20, команда     let [c_before, c] = matches[1:2]
строка 21, команда   endif
строка 22, команда   let plist = split(&matchpairs, '.\zs[:,]')
строка 23, команда   let i = index(plist, c)
строка 24, команда   if i < 0
строка 25, команда     " not found, in Insert mode try character before the cursor
строка 26, команда     if c_col > 1 && (mode() == 'i' || mode() == 'R')
строка 27, команда       let before = strlen(c_before)
строка 28, команда       let c = c_before
строка 29, команда       let i = index(plist, c)
строка 30, команда     endif
строка 31, команда     if i < 0
строка 32, команда       " not found, nothing to do
строка 33, команда       return
строка 34, команда     endif
строка 35, команда   endif
строка 36, команда 
строка 37, команда   " Figure out the arguments for searchpairpos().
строка 38, команда   if i % 2 == 0
строка 39, команда     let s_flags = 'nW'
строка 40, команда     let c2 = plist[i + 1]
строка 41, команда   else
строка 42, команда     let s_flags = 'nbW'
строка 43, команда     let c2 = c
строка 44, команда     let c = plist[i - 1]
строка 45, команда   endif
строка 46, команда   if c == '['
строка 47, команда     let c = '\['
строка 48, команда     let c2 = '\]'
строка 49, команда   endif
строка 50, команда 
строка 51, команда   " Find the match.  When it was just before the cursor move it there for a
строка 52, команда   " moment.
строка 53, команда   if before > 0
строка 54, команда     let has_getcurpos = exists("*getcurpos")
строка 55, команда     if has_getcurpos
строка 56, команда       " getcurpos() is more efficient but doesn't exist before 7.4.313.
строка 57, команда       let save_cursor = getcurpos()
строка 58, команда     else
строка 59, команда       let save_cursor = winsaveview()
строка 60, команда     endif
строка 61, команда     call cursor(c_lnum, c_col - before)
строка 62, команда   endif
строка 63, команда 
строка 64, команда   if !has("syntax") || !exists("g:syntax_on")
строка 65, команда     let s_skip = "0"
строка 66, команда   else
строка 67, команда     " Build an expression that detects whether the current cursor position is
строка 68, команда     " in certain syntax types (string, comment, etc.), for use as
строка 69, команда     " searchpairpos()'s skip argument.
строка 70, команда     " We match "escape" for special items, such as lispEscapeSpecial, and
строка 71, команда     " match "symbol" for lispBarSymbol.
строка 72, команда     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
строка 74, команда     " If executing the expression determines that the cursor is currently in
строка 75, команда     " one of the syntax types, then we want searchpairpos() to find the pair
строка 76, команда     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
строка 77, команда     " outside of the syntax types and s_skip should keep its value so we skip
строка 78, команда     " any matching pair inside the syntax types.
строка 79, команда     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
строка 80, команда     try
строка 81, команда       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
строка 81, команда if !empty(filter(map(synstack(line("."), col(".")), 'synIDattr(v:val, "name")'), 'v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"')) | let s_skip = "0" | endif
строка 81, команда  let s_skip = "0" | endif
строка 81, команда  endif
строка 82, команда     catch /^Vim\%((\a\+)\)\=:E363/
строка 83, команда       " We won't find anything, so skip searching, should keep Vim responsive.
строка 84, команда       return
строка 85, команда     endtry
строка 86, команда   endif
строка 87, команда 
строка 88, команда   " Limit the search to lines visible in the window.
строка 89, команда   let stoplinebottom = line('w$')
строка 90, команда   let stoplinetop = line('w0')
строка 91, команда   if i % 2 == 0
строка 92, команда     let stopline = stoplinebottom
строка 93, команда   else
строка 94, команда     let stopline = stoplinetop
строка 95, команда   endif
строка 96, команда 
строка 97, команда   " Limit the search time to 300 msec to avoid a hang on very long lines.
строка 98, команда   " This fails when a timeout is not supported.
строка 99, команда   if mode() == 'i' || mode() == 'R'
строка 100, команда     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
строка 101, команда   else
строка 102, команда     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
строка 103, команда   endif
строка 104, команда   try
строка 105, команда     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
строка 106, команда   catch /E118/
строка 107, команда     " Can't use the timeout, restrict the stopline a bit more to avoid taking
строка 108, команда     " a long time on closed folds and long lines.
строка 109, команда     " The "viewable" variables give a range in which we can scroll while
строка 110, команда     " keeping the cursor at the same position.
строка 111, команда     " adjustedScrolloff accounts for very large numbers of scrolloff.
строка 112, команда     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
строка 113, команда     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
строка 114, команда     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
строка 115, команда     " one of these stoplines will be adjusted below, but the current values are
строка 116, команда     " minimal boundaries within the current window
строка 117, команда     if i % 2 == 0
строка 118, команда       if has("byte_offset") && has("syntax_items") && &smc > 0
строка 119, команда ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
строка 120, команда ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
строка 121, команда       else
строка 122, команда ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
строка 123, команда       endif
строка 124, команда       let stoplinebottom = stopline
строка 125, команда     else
строка 126, команда       if has("byte_offset") && has("syntax_items") && &smc > 0
строка 127, команда ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
строка 128, команда ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
строка 129, команда       else
строка 130, команда ^Ilet stopline = max([top_viewable, c_lnum - 100])
строка 131, команда       endif
строка 132, команда       let stoplinetop = stopline
строка 133, команда     endif
строка 134, команда     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
строка 135, команда   endtry
строка 136, команда 
строка 137, команда   if before > 0
строка 138, команда     if has_getcurpos
строка 139, команда       call setpos('.', save_cursor)
строка 140, команда     else
строка 141, команда       call winrestview(save_cursor)
строка 142, команда     endif
строка 143, команда   endif
строка 144, команда 
строка 145, команда   " If a match is found setup match highlighting.
строка 146, команда   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
строка 147, команда     if exists('*matchaddpos')
строка 148, команда       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
строка 149, команда     else
строка 150, команда       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
строка 152, команда     endif
строка 153, команда     let w:paren_hl_on = 1
строка 154, команда   endif
<SNR>30_Highlight_Matching_Pair вернула #0

Начинается обработка для события TextChanged автокоманды "*"


Выполнение w
"HiAttr2CssDecl.vim" 
"HiAttr2CssDecl.vim" 297L, 9616B
"HiAttr2CssDecl.vim" 297L, 9616B
Запись viminfo-файла "D:\Users\Iam\_viminfo"
Выполнение для события VimLeave автокоманды "*"
автокоманда call s:persistCache()

Выполнение call s:persistCache()
вызов <SNR>33_persistCache()

строка 1, команда ^Ilet l:cacheList = []
строка 2, команда ^Ilet l:mergedCache = extend(s:readCache(), s:cache)
вызов <SNR>33_readCache()

строка 1, команда ^Iif !filereadable(g:semanticPersistCacheLocation)
строка 2, команда ^I^Ireturn []
строка 3, команда ^Iendif
строка 4, команда 
строка 5, команда ^Ilet l:localCache = {}
строка 6, команда ^Ilet s:cacheList = readfile(g:semanticPersistCacheLocation)
строка 7, команда ^Ifor s:cacheListItem in s:cacheList
строка 8, команда ^I^Ilet s:cacheListItemList = eval(s:cacheListItem)
строка 9, команда ^I^Ilet l:localCache[s:cacheListItemList[0]] = s:cacheListItemList[1]
строка 10, команда ^Iendfor
строка 11, команда 
строка 12, команда ^Iif exists("s:cacheListItem")
строка 13, команда ^I^Iunlet s:cacheListItem s:cacheList
строка 14, команда ^Iendif
строка 15, команда 
строка 16, команда ^Ireturn l:localCache
<SNR>33_readCache вернула {}

Начинается обработка <SNR>33_persistCache

строка 3, команда ^Ifor [match,color] in items(l:mergedCache)
строка 4, команда ^I^Icall add(l:cacheList, string([match, color]))
строка 5, команда ^I^Iunlet match color
строка 6, команда ^Iendfor
строка 7, команда ^Icall writefile(l:cacheList, g:semanticPersistCacheLocation)
<SNR>33_persistCache вернула #0

Начинается обработка для события VimLeave автокоманды "*"
